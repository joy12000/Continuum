var k=Object.defineProperty;var A=(n,t,e)=>t in n?k(n,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[t]=e;var c=(n,t,e)=>A(n,typeof t!="symbol"?t+"":t,e);function v(n){try{const t=document.createElement("div");return t.innerHTML=n,(t.textContent||t.innerText||"").trim()}catch{return n}}function P(n){return n=v(n),n.toLowerCase().replace(/[\p{P}\p{S}]+/gu," ").split(/\s+/).filter(Boolean).filter(o=>o.length>=2)}const w=384;function S(n){let t=5381;for(let e=0;e<n.length;e++)t=(t<<5)+t^n.charCodeAt(e);return t>>>0}function x(n){let t=0;for(let s=0;s<n.length;s++)t+=n[s]*n[s];const e=t>0?1/Math.sqrt(t):1;for(let s=0;s<n.length;s++)n[s]*=e}function L(n){const t=P(n),e=new Float32Array(w);for(const s of t){const o=`^${s}$`;for(let i=3;i<=5;i++)for(let r=0;r+i<=o.length;r++){const a=o.slice(r,r+i),h=S(a)%w;e[h]+=1}}return x(e),Array.from(e)}const T="/api";class z{constructor(t=T){c(this,"name","remote-api");this.base=t}async ensureReady(){return!0}async embed(t){const e=await fetch(`${this.base}/embed`,{method:"POST",headers:{"content-type":"application/json"},body:JSON.stringify({texts:t,output_dimensionality:384})});if(!e.ok)throw new Error(`Remote embed failed: ${e.status}`);const s=await e.json();return Array.isArray(s.vectors)?s.vectors:Array.isArray(s.vector)?[s.vector]:t.map(()=>[])}}class C{constructor(){c(this,"vocab",new Map);c(this,"inv",[]);c(this,"ready",!1);c(this,"CLS",101);c(this,"SEP",102);c(this,"PAD",0);c(this,"UNK",100);c(this,"maxLen",128)}async load(t="/models/vocab.txt"){if(this.ready)return!0;const e=await fetch(t);if(!e.ok)return!1;const o=(await e.text()).split(/\r?\n/);this.inv=[],this.vocab.clear();for(let i=0;i<o.length;i++){const r=o[i].trim();r&&(this.vocab.set(r,i),this.inv.push(r))}return this.CLS=this.vocab.get("[CLS]")??this.CLS,this.SEP=this.vocab.get("[SEP]")??this.SEP,this.PAD=this.vocab.get("[PAD]")??this.PAD,this.UNK=this.vocab.get("[UNK]")??this.UNK,this.ready=!0,!0}basicTokenize(t){return t=t.normalize("NFKC").toLowerCase(),t=t.replace(/([\p{P}])/gu," $1 "),t.split(/\s+/).filter(Boolean)}wordpiece(t){if(this.vocab.has(t))return[this.vocab.get(t)];const e=t,s=[];let o=0;for(;o<e.length;){let i=e.length,r=null;for(;o<i;){let a=e.slice(o,i);o>0&&(a="##"+a);const h=this.vocab.get(a);if(h!=null){r=h;break}i-=1}if(r==null)return[this.UNK];s.push(r),o=i}return s}async encode(t){if(!this.ready&&!await this.load())return{ids:[],mask:[]};const e=[],s=this.basicTokenize(t);for(const h of s){const d=this.wordpiece(h);e.push(...d)}const o=this.maxLen-2,i=e.slice(0,o),r=[this.CLS,...i,this.SEP],a=new Array(r.length).fill(1);for(;r.length<this.maxLen;)r.push(this.PAD),a.push(0);return{ids:r,mask:a}}}class I{constructor(){c(this,"name","hashing-ngram")}async ensureReady(){return!0}async embed(t){return t.map(e=>L(e))}}class B{constructor(){c(this,"name","onnxruntime");c(this,"session",null);c(this,"tokenizer",null);c(this,"modelUrl",null)}async probe(t){try{return(await fetch(t,{method:"HEAD"})).ok}catch{return!1}}async hasFiles(){const t=await this.probe("/models/encoder.int8.onnx"),e=await this.probe("/models/encoder.onnx");return await this.probe("/models/vocab.txt")?(this.modelUrl=t?"/models/encoder.int8.onnx":e?"/models/encoder.onnx":null,!!this.modelUrl):!1}async ensureReady(){if(this.session&&this.tokenizer)return!0;if(!await this.hasFiles())return!1;const t=await import("./ort.bundle.min-CSv9RFlt.js");return this.tokenizer=new C,await this.tokenizer.load("/models/vocab.txt")?(this.session=await t.InferenceSession.create(this.modelUrl,{executionProviders:["wasm"]}),!0):!1}async embed(t){if(!await this.ensureReady()||!this.session||!this.tokenizer)return t.map(()=>[]);const s=await import("./ort.bundle.min-CSv9RFlt.js"),o=[];for(const i of t){const r=await this.tokenizer.encode(i);if(r.ids.length===0){o.push([]);continue}const a=r.ids.length;let h;try{h={input_ids:new s.Tensor("int64",BigInt64Array.from(r.ids.map(BigInt)),[1,a]),attention_mask:new s.Tensor("int64",BigInt64Array.from(r.mask.map(BigInt)),[1,a])}}catch{h={input_ids:new s.Tensor("int32",Int32Array.from(r.ids),[1,a]),attention_mask:new s.Tensor("int32",Int32Array.from(r.mask),[1,a])}}const d=await this.session.run(h),b=Object.keys(d)[0],p=d[b].data,m=p.length/a,u=new Float32Array(m);for(let l=0;l<a;l++)if(r.mask[l]!==0)for(let f=0;f<m;f++)u[f]+=p[l*m+f];let y=0;for(let l=0;l<u.length;l++)y+=u[l]*u[l];const g=y>0?1/Math.sqrt(y):1;for(let l=0;l<u.length;l++)u[l]*=g;o.push(Array.from(u))}return o}}async function E(){try{const n=new B;return await n.ensureReady()?n:null}catch{return null}}async function D(n="auto"){if(n==="remote")return new z;const t=await E();return t||new I}export{D as getSemanticAdapter};
